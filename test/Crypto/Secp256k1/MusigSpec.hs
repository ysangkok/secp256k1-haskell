{-# LANGUAGE ScopedTypeVariables, DataKinds, TypeApplications #-}
module Crypto.Secp256k1.MusigSpec where

import Prelude hiding (replicate)
import GHC.TypeLits.Witnesses (SNat(SNat))
import Data.ByteString (replicate)
import Data.Functor.Identity (Identity)
import Data.Vector.Fixed hiding (replicate)
import Foreign.C (CInt)

import Crypto.Secp256k1

import Test.Hspec
import Test.HUnit (Assertion, assertBool, assertEqual)

spec :: Spec
spec = do
  describe "the musig binding" $ do
    it "works with one signer" oneParticipantTest
    it "cannot combine 0 keys" (assertEqual "should get nothing" Nothing (fmap fst (wMusigPubKeyCombine (mk0 @Empty))))
    it "can support multi-hop locks" multiHopLocksTest

oneParticipantTest :: Assertion
oneParticipantTest = do
  let Just pri0 = secKey $ replicate 32 100
  let Just com2 = nonceCommitment $ replicate 32 70
  let Just id2 = sessionId $ replicate 32 80
  let Just messageHash = msg $ replicate 32 65
  let Just (combinedPk, preSession) = wMusigPubKeyCombine (mk1 @Identity $ createXOnlyPubKey pri0)
  Just (sess2, data2 :: WSignerData 1) <-
          wMusigSessionInit
              com2
              id2
              messageHash
              combinedPk
              preSession
              0
              pri0
              SNat
  Just pubnonce2 <- wMusigGetPublicNonce sess2 data2 (mk1 @Identity com2)
  True <- wMusigSetNonce data2 pubnonce2 0
  let Just (round2_2, _isNegated2) = wMusigCombineNonces sess2 data2 Nothing SNat
  let sig1 = wMusigPartialSign round2_2
  let Just combinedSig = wMusigPartialSignatureCombine (mk1 @Identity sig1) round2_2
  assertBool "signature verifies" (verifyMsgSchnorr combinedPk combinedSig messageHash)

musigBetween :: Msg
             -> SecKey -- sender privkey
             -> SecKey -- receiver privkey
             -> XOnlyPubKey -- adaptor pubkey
             -> IO ((WPartialSignature, CInt, WMusigRound2 2), -- sender
                    WPartialSignature, -- receiver
                    XOnlyPubKey) -- combined pubkey
musigBetween messageHash pri0 pri1 adaptor =
  let
    pub0 = createXOnlyPubKey pri0
    pub1 = createXOnlyPubKey pri1
    Just (combinedPk, preSession) = wMusigPubKeyCombine (pub0,pub1)

    Just com0 = nonceCommitment $ replicate 32 10
    Just com1 = nonceCommitment $ replicate 32 11
    Just id0 = sessionId $ replicate 32 20
    Just id1 = sessionId $ replicate 32 21

  in do
      Just (sess0, data0) <-
          wMusigSessionInit
              com0
              id0
              messageHash
              combinedPk
              preSession
              0
              pri0
              SNat
      Just (sess1, data1) <-
          wMusigSessionInit
              com1
              id1
              messageHash
              combinedPk
              preSession
              1
              pri1
              SNat
      Just pubnonce0 <- wMusigGetPublicNonce sess0 data0 (com0,com1)
      Just pubnonce1 <- wMusigGetPublicNonce sess1 data1 (com0,com1)
      True <- wMusigSetNonce data0 pubnonce0 0
      True <- wMusigSetNonce data1 pubnonce0 0
      True <- wMusigSetNonce data0 pubnonce1 1
      True <- wMusigSetNonce data1 pubnonce1 1

      let Just (round2_0,  isNegated0) = wMusigCombineNonces sess0 data0 (Just adaptor) SNat
      let Just (round2_1, _isNegated1) = wMusigCombineNonces sess1 data1 (Just adaptor) SNat
      let sig0 = wMusigPartialSign round2_0
      let sig1 = wMusigPartialSign round2_1
      return $ ((sig0, isNegated0, round2_0), sig1, combinedPk)

multiHopLocksTest :: Assertion
multiHopLocksTest = do
  -- This is the proof of payment generated by C, A wants this but only has zG.
  let Just z = secKey $ replicate 32 2
  -- This is generated by A. Not sent to anyone. Used to recover z.
  let Just y0 = tweak $ replicate 32 3
  -- This is generated by A. Sent to B during setup. Used to recover z+y0.
  let Just y1 = tweak $ replicate 32 5
  -- A learns this if their money is taken. It is used to recover z.
  let Just z_y0 = schnorrTweakAddSecKey z y0
  -- B learns this if their money is taken. It is used to recover z+y0.
  let Just z_y0_y1 = schnorrTweakAddSecKey z_y0 y1
  -- This is generated by the receiver (C). It is in the invoice.
  let zG = createXOnlyPubKey z
  -- This is generated by A, and sent to A and B during setup. It is the right lock of A and the left lock of B.
  let Just (z_y0G, _isNegated) = schnorrTweakAddPubKey zG y0
  -- This is generated by A, and sent to B and C during setup. It is the right lock of B and the left lock of C.
  let Just (z_y0_y1G, _isNegated) = schnorrTweakAddPubKey z_y0G y1

  assertBool "Node A adds y0*G and y1*G to z*G correctly" $
             z_y0_y1G == createXOnlyPubKey z_y0_y1

  let Just pri0 = secKey $ replicate 32 10
  let Just pri1 = secKey $ replicate 32 20
  let Just pri2 = secKey $ replicate 32 30
  let Just pri3 = secKey $ replicate 32 40

  let Just messageHash = msg $ replicate 32 64

  -- UPDATE PHASE --
  ((temp_sig0, isNegated0, round2_0 :: WMusigRound2 2), sig1, combinedPk0) <- musigBetween messageHash pri0 pri1 z_y0G
  ((temp_sig2, isNegated2, round2_2 :: WMusigRound2 2), sig3, combinedPk2) <- musigBetween messageHash pri2 pri3 z_y0_y1G

  -- SETTLEMENT PHASE --

  -- C publishes on chain
  let Just sig2 = wMusigPartialSignatureAdapt sig3 temp_sig2 z_y0_y1 isNegated2
  let Just combinedSig2 = wMusigPartialSignatureCombine (sig2, sig3) round2_2
  assertBool "Node C produces valid signature" $
             verifyMsgSchnorr combinedPk2 combinedSig2 messageHash

  -- The calls to wMusigExtractSecKey correspond to the
  -- following equation in the multi-hop-locks document:
  -- sig(tx,T) - psig(i,tx,Ri) - psig(j,tx,Lj) = adaptor_sig(j,tx,Lj) - psig(j,tx,Lj) = yj

  -- B recovers z+y0+y1:
  let Just potential_z_y0_y1 = wMusigExtractSecKey combinedSig2 [temp_sig2, sig3] isNegated2
  assertBool "Node B recovers 'z+y0+y1' corresponding to '(z+y0+y1)*G'" $
             createXOnlyPubKey potential_z_y0_y1 == z_y0_y1G

  -- B subtracts y1 to get z+y0
  let Just negated_y1 = tweakNegate y1
  -- B verifies that what was received was indeed their 'preimage'
  let Just potential_z_y0 = schnorrTweakAddSecKey z_y0_y1 negated_y1
  assertBool "Node B recovers 'z+y0' corresponding to '(z+y0)*G'" $
             createXOnlyPubKey potential_z_y0 == z_y0G

  -- B publishes on chain
  let Just sig0 = wMusigPartialSignatureAdapt sig1 temp_sig0 z_y0 isNegated0
  let Just combinedSig0 = wMusigPartialSignatureCombine (sig0, sig1) round2_0
  assertBool "Node B produces valid signature" $
             verifyMsgSchnorr combinedPk0 combinedSig0 messageHash

  -- A recovers z+y0
  assertBool "Node A recovers z+y0" $ Just z_y0 == wMusigExtractSecKey combinedSig0 [temp_sig0, sig1] isNegated0
  -- A subtracts y0 to get z
  let Just negated_y0 = tweakNegate y0
  let Just potential_z = schnorrTweakAddSecKey z_y0 negated_y0
  -- A verifies that what was received was indeed their 'preimage', the proof-of-payment (z)
  assertBool "Node A recovers 'z' corresponding to 'z*G'" $
             createXOnlyPubKey potential_z == zG
